\documentclass[11pt]{article}
\usepackage{algorithm2e}
\usepackage[italian]{babel}
\usepackage[document]{ragged2e}
\usepackage{amsfonts, amssymb, amsmath}
\usepackage{cancel}
\usepackage{float}
\usepackage{mathtools}
\usepackage[margin=3cm]{geometry}

\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\hbadness=10000

% TODO: 
% SISTEMARE LE PAGINE. GRAZIE.

\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1.5cm}
            
        \Huge
        \textbf{MNK-GAME}
            
        \vspace{0.5cm}
        \LARGE
        Relazione
            
        \vspace{1.5cm}
          
        \begin{minipage}[t]{0.47\textwidth}
        \begin{center}
        	{\large{\bf Cheikh Ibrahim $\cdot$ Zaid}}\\
			{\large Matricola: \texttt{0000974909}}
        \end{center}

		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.47\textwidth}\raggedleft
		\begin{center}
        	{\large{\bf Xia $\cdot$ Tian Cheng}}\\
			{\large Matricola: \texttt{0000975129}}
        \end{center}
		\end{minipage}  
            
        \vspace{6cm}
            
        Anno accademico\\
        $2020 - 2021$
            
        \vspace{0.8cm}
            
            
        \Large
        Corso di Algoritmi e Strutture Dati\\
        Alma Mater Studiorum $\cdot$ Università di Bologna\\
            
    \end{center}
\end{titlepage}
\pagebreak


\section*{Introduzione}
\justify
Il progetto MNK-Game consiste nella realizzazione di un algoritmo in grado di giocare a una versione generalizzata del Tris.\\
La criticità maggiore risiede nella valutazione delle possibili mosse da eseguire che crescono esponenzialmente nel progredire del gioco, rendendo impossibile la risoluzione del problema tramite forza bruta.\\
Contemporaneamente però, l'algoritmo deve avere, come requisito minimo, la capacità di effettuare scelte qualitativamente accettabili.

\section*{Scelte progettuali}
\subsection*{Classi implementate}
Le classi implementate dall'algoritmo sono le seguenti:
\begin{table}[H]	% [H] per non stampare la tabella a inizio file. Richiede package float
\centering			% centra la tabella
\def\arraystretch{1.5}
\begin{tabular}{|l|p{3in}|}	% 2 colonne separate da | allineate a sinistra con la seconda colonna "paragrafo da 3 inch"
\hline	% hline per la linea orizzontale
\texttt{OurPlayer} & Implementa l'interfaccia \texttt{MNKPlayer} \\ \hline
\texttt{Node} & Rappresenta un nodo dell'albero di gioco \\ \hline
\texttt{GameTree} & Contiene l'albero di gioco e implementa i metodi per manipolarlo \\ \hline
\texttt{Matrix} & Rappresenta una configurazione della griglia di gioco \\ \hline
\texttt{BoardStatus} & Permette di ricavare informazioni su una configurazione di gioco \\ \hline
\texttt{Coord} & Rappresenta una coordinata \\ \hline
\texttt{EstimatedPosition} & Descrive una possibile mossa quantificata da un punteggio \\ \hline
\end{tabular}
\end{table}

\subsection*{Funzionamento generale}
Data l'impossibilità di generare tutti i possibili scenari, si rende necessario trovare e valutare solo le mosse realmente proficue tramite funzioni euristiche.\\
Inoltre, bisogna limitare la generazione in altezza dell'albero per mantenere accettabile il tempo di risposta dell'algoritmo, rendendo quindi necessario valutare lo stato delle foglie contenenti configurazioni di gioco intermedie.\\
(((((Le funzioni euristiche di questo algoritmo si basano sul numero di allineamenti effettivi e possibili del giocatore e dell'avversario)))))).

\subsection*{Quantificazione degli allineamenti}
\subsubsection*{Descrizione}
Per quantificare i possibili allineamenti del giocatore e dell'avversario, viene utilizzato il metodo \texttt{getScoresArray} della classe \texttt{BoardStatus} che implementa un algoritmo basato sulla programmazione dinamica che prende in input il vettore $I[0 .. n-1]$ contenente la configurazione di gioco di ciascuna cella rispetto ad una direzione rappresentata da \texttt{PLAYER}, \texttt{OPPONENT}, \texttt{FREE} e restituisce il vettore $S[0 .. n-1]$, ove $S[i]$ contiene la tupla di interi:\\
\centerline{(\texttt{celle allineabili}, \texttt{mosse necessarie alla vittoria}, \texttt{punto inizio allineamento})}\\
che rappresentano le informazioni sulla possibile mossa all'$i$-esima cella. Le seguenti equazioni di ricorrenza descrivono le varie casistiche previste dall'algoritmo:\\
\begin{equation*}
	S[0] \leftarrow
	\begin{cases}
	(0,0,-1) & \mbox{se } I[0]=\mbox{\texttt{OPPONENT}} \\ 
	(1,0,-1) & \mbox{se } I[0]=\mbox{\texttt{PLAYER}} \\
	(1,1,-1) & \mbox{se } I[0]=\mbox{\texttt{FREE}}
	\end{cases}
\end{equation*}
% ---------------- DEFINIRE K ----------------
\begin{equation*}
\mathclap {
	S[i] \leftarrow
	\begin{cases}
	(0,0,-1) & \mbox{se } I[i]=\mbox{\texttt{OPPONENT}} \\ 
	(S[i-1].\text{aligned}+1,S[i-1].\text{moves},-1) & \mbox{se } S[i-1].\text{aligned} < K \texttt{ AND } I[i] = \texttt{PLAYER}\\
	(S[i-1].\text{aligned}+1,S[i-1].\text{moves}+1,-1) & \mbox{se } S[i-1].\text{aligned} < K \texttt{ AND } I[i] = \texttt{FREE}\\
	\end{cases}
}
\end{equation*}

\begin{equation*}
\mathclap {
	\text{se } I[i]=\texttt{PLAYER}\Rightarrow S[i] \leftarrow
	\begin{cases}
	(S[i-1].\text{aligned},S[i-1].\text{moves}-1,i-(K-1)) & \mbox{se } I[i-K] =\texttt{FREE}\\
	(S[i-1].\text{aligned},S[i-1].\text{moves},i-(K-1)) & \mbox{se } I[i-K] =\texttt{PLAYER}\\
	\end{cases}
}
\end{equation*}

\begin{equation*}
\mathclap {
	\text{se } I[i]=\texttt{FREE}\Rightarrow S[i] \leftarrow
	\begin{cases}
	(S[i-1].\text{aligned},S[i-1].\text{moves},i-(K-1)) & \mbox{se } I[i-K] =\texttt{FREE}\\
	(S[i-1].\text{aligned},S[i-1].\text{moves}+1,i-(K-1)) & \mbox{se } I[i-K] =\texttt{PLAYER}\\
	\end{cases}
}
\end{equation*}
\\
Per trovare il numero di mosse ottimali per ciascuna cella, alla posizione $i$-esima, avviene una fase di propagazione del punteggio:
\begin{algorithm*}
\SetAlgoLined
 \For{$j \gets i-1$ to $i-K+1$}{
 \textit{// L'allineamento viene interrotto da una mossa dell'avversario\\}
  \If{$I[j] = \texttt{OPPONENT}$}{
  	\texttt{break}
  	}
  \textit{// Le mosse precedenti sono migliori, non serve propagare\\}
  \If{$S[j].\text{aligned} = K \texttt{ AND } S[j].\text{moves} < S[i].\text{moves}$}{
   	\texttt{break}
   }
   $S[i-j] = S[i]$
 }
\end{algorithm*}\\
Per calcolare i valori in relazione all'avversario è sufficiente invertire \texttt{PLAYER} e \texttt{OPPONENT}.
\subsubsection*{Costo computazionale}
L'algoritmo deve necessariamente iterare per intero il vettore $I$ con un costo di $\Theta(I.\text{length})$, in aggiunta, per ciascun ciclo c'è la possibilità di dover propagare la tupla calcolata alle celle antecedenti.\\
Nel caso pessimo, quindi, si ha un costo computazionale di O$(I.\texttt{length} \cdot K)$, ovvero la propagazione avviene per ogni posizione.
\subsection*{Generazione punteggi}
\subsubsection*{Descrizione}
La classe \texttt{BoardStatus} implementa le funzioni \texttt{generateMovesToWinAt} e \texttt{generateGlobalMovesToWin} che utilizzano il metodo \texttt{getScoresArray} per generare le tuple rispetto ad una riga, colonna o diagonale.\\
In particolare: 
\begin{itemize}
\setlength\itemsep{0.05cm}
	\item \texttt{generateMovesToWinAt} prende in input una coordinata e genera i punteggi della riga, colonna e diagonali che passano per quel punto
	\item \texttt{generateGlobalMovesToWin} genera il punteggio per tutte le posizioni rispetto a tutte le direzioni
\end{itemize}
L'output viene memorizzato in delle matrici interne alla classe per evitare di dover rigenerare le tuple nel caso si dovesse accedere a celle adiacenti.
\subsubsection*{Costo computazionale}
La funzione \texttt{generateMovesToWinAt}, nel caso pessimo, ha costo O$(\texttt{max}\{M, N\} \cdot K) = \text{O}(MK+NK)$ dato dalla necessità di iterare tutte le direzioni rispetto ad una coordinata (quindi ha maggior peso la riga/colonna con più celle).\\
Nel caso ottimo, invece, ha costo $\Theta(1)$, ovvero quando gli score sono già stati generati e memorizzati nelle matrici.\\
La funzione \texttt{generateGlobalMovesToWin}, nel caso pessimo, ha costo O$(MNK)$ perché bisogna iterare l'intera griglia di gioco.

\subsection*{Euristica su configurazioni intermedie}
\subsubsection*{Descrizione}
La classe \texttt{GameTree} implementa il metodo \texttt{setHeuristicScoreOf} che prende in input un nodo dell'albero, un oggetto \texttt{BoardStatus} e un flag per indicare chi deve eseguire la prossima mossa e imposta a quel nodo un punteggio euristico.\\
L'implementazione prevede di generare il numero di mosse necessarie per vincere a tutte le celle e di ricavare, sia per il giocatore che per l'avversario, il numero di possibili scenari vincenti che necessitano di piazzare da $1$ a $n$ mosse e con queste calcola il punteggio finale assegnando un peso per ciascuna tipologia.\\
Vengono quindi gestite tre casistiche: 
\begin{enumerate}
\setlength\itemsep{0.05cm}
	\item Se è il turno del giocatore e ha la possibilità di vincere immediatamente, viene assegnato il punteggio vincente
	\item Se è il turno dell'avversario e ha la possibilità di vincere immediatamente, viene assegnato il punteggio perdente
	\item Altrimenti viene assegnata la differenza tra il punteggio del giocatore e quello dell'avversario.
\end{enumerate}
\subsubsection*{Costo computazionale}
La funzione \texttt{setHeuristicScoreOf} ha costo O$(MNK)$ dato dalla chiamata al metodo \texttt{generateGlobalMovesToWin}.

\subsection*{Ricerca della mossa successiva}
\subsubsection*{Descrizione}
Nella classe \texttt{BoardStatus} viene implementato il metodo \texttt{getAdjacency} che, a partire da un nodo dell'albero, scansiona le celle vuote adiacenti a tutte le mosse effettuate e restituisce una coda con priorità contenente tutte le mosse analizzate ordinate in base all'importanza.\\
Per marcare le celle visitate si utilizza una hash table che associa ad una coordinata un booleano, per evitare di dover allocare un'intera matrice di dimensione $\Theta(MN)$, avendo comunque un tempo di accesso medio di O$(1)$.\\
Le mosse valutate si basano sul seguente ordine di priorità:
\begin{table}[H]	% [H] per non stampare la tabella a inizio file. Richiede package float
\centering			% centra la tabella
\def\arraystretch{1.5}
\begin{tabular}{|l|p{3in}|}	% 2 colonne separate da | allineate a sinistra con la seconda colonna "paragrafo da 3 inch"
\hline	% hline per la linea orizzontale
Priorità 1 & Mossa immediatamente vincente \\ \hline
Priorità 2 & Blocca una mossa immediatamente vincente dell'avversario \\ \hline
Priorità 3 & Piazza una mossa che crea un vicolo cieco per l'avversario (ovvero una mossa che apre più scenari di vittoria immediata) \\ \hline
Priorità 4 & Blocca la creazione di un vicolo cieco da parte dell'avversario \\ \hline
Altrimenti & Piazza una mossa che aumenta un allineamento del giocatore dando priorità ad allineamenti più lunghi e in grado di bloccare la sequenza maggiore dell'avversario \\ \hline
\end{tabular}
\end{table}
$ $\\
Le mosse con priorità $\leq 4$ sono considerate critiche in quanto permettono di aprire scenari a vittoria o sconfitta certa.
\subsubsection*{Costo computazionale}
Il costo computazionale è O$(h(MK+NK+\log h))$, dove $h$ è l'altezza dell'albero di gioco.\\
Il costo è dato dal ciclo di costo $\Theta(h)$ che scorre per intero l'albero e per ciascuna iterazione analizza al più un numero costante di 8 celle (tutte le possibili direzioni). Il costo maggiore all'interno del ciclo è dato dalla chiamata alla funzione \texttt{generateMovesToWinAt} di costo O$(MK+NK)$.\\
Inoltre ogni mossa elaborata viene inserita in una coda con priorità che ha un costo computazionale logaritmico rispetto alla dimensione della coda. Ipotizzando che ad ogni iterazione si inserisca sempre nella coda, il costo è il seguente (utilizzando l'approssimazione di Stirling del fattoriale):
\begin{align*}
\sum_{i=1}^{h} \log i = \log h! = \log \sqrt{2\pi h} \left(\dfrac{h}{e}\right)^h = \cancel{\log \sqrt{2 \pi}} + \cancel{\log \sqrt{h}} + h \log \dfrac{h}{\cancel{e}} = \text{O}(h \log h)
\end{align*}

\subsection*{Generazione albero di gioco}
\subsubsection*{Descrizione}
Il metodo \texttt{createTree} nella classe \texttt{GameTree} prende in input un nodo dell'albero e un intero rappresentante il numero di livelli da generare e genera l'albero di gioco radicato in quel nodo.\\
Il funzionamento si basa sul seguente pseudocodice:
\begin{algorithm*}
\SetAlgoLined
\SetKwProg{Fn}{Function}{}{end}
\Fn{\normalfont \texttt{createTree}(nodo, depth)}{
	\texttt{generateMovesToWinAt(}coordinate della mossa nel nodo\texttt{)} \\
	\vspace{0.2cm}
	\uIf{partita terminata}{
		imposta punteggio reale
	}
	\uElseIf{depth $\leq 0$}{
		imposta punteggio euristico
	}
	\Else{
		\texttt{PriorityQueue} mosse $\gets$ \texttt{getAdjacency(}a partire dal nodo\texttt{)} \\
		\While{ci sono mosse promettenti}{
			\texttt{createTree(}nodo da visitare, depth$-1$\texttt{)}
		}
	}
}
\end{algorithm*}\\
La selezione delle mosse promettenti è basato sul seguente criterio:
\begin{itemize}
\setlength\itemsep{0.05cm}
	\item Se la mossa è critica, valuto tutte quelle equivalenti (ad esempio se c'è la possibilità di vincere immediatamente, non è necessario valutare mosse di tipologia diversa)
	\item Se la mossa non è critica, valuto al più un numero fissato.
\end{itemize}
\subsubsection*{Costo computazionale}
La funzione è si basa sulla seguente funzione di ricorrenza:
\begin{equation*}
\mathclap {
	T(\text{depth}) =
	\begin{cases}
	MK+NK & \mbox{se partita terminata}\\ 
	\cancel{(MK+NK)}+MNK & \mbox{se depth $\leq$ 0}\\
	\cancel{(MK+NK)}+h(MK+NK+\log h)+p(M+N)+p\log h+pT(depth-1) & \mbox{altrimenti}\\
	\end{cases}
}
\end{equation*}
Dove $h$ è l'altezza dell'albero, $p$ è il numero di iterazioni del ciclo \texttt{while} (nodi promettenti) e $q$ è il numero di possibili mosse (dimensione della coda con priorità).\\
Assumendo che il numero di iterazioni $p$ sia in media coerente con il valore soglia stabilito, possiamo trattarlo come una costante, quindi la complessità computazionale della terza equazione è:
\begin{equation*}
h(MK+NK+\log h)+\cancel{p(M+N)}+\cancel{p}\log q+\cancel{p}T(depth-1)=\\
\end{equation*}
\begin{equation*}
=h(MK+NK+\log h)+\log q+T(depth-1)=\\
\end{equation*}
\begin{equation*}
=h(MK+NK)+h\log h + \log q+T(depth-1)=\\
\end{equation*}
Risolvendo per iterazione, otteniamo che il costo è:
\begin{equation*}
=(h(MK+NK)+h\log h + \log q)\cdot (depth\cancel{-1}) + \cancel{MNK}=\\
\end{equation*}
\begin{equation*}
=depth \cdot h(MK+NK)+depth(h\log h + \log q)\\
\end{equation*}
\textbf{FIXAREEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE $\downarrow$}\\
Dimostriamo, applicando la definizione in modo diretto, che $\log q =$ O$(h\log h)$, ovvero, vogliamo provare che $\exists c > 0, n_0 \geq 0 \text{ t.c. } \forall n \geq n_0 : \log q \leq c \cdot (h \log h)$.\\
Possiamo porre $c = 1$ e mostrare che per un $n_0 \geq 0 $ si ha che $\log q \leq h \log h$.\\
Ricordando che $h$ è l'altezza dell'albero di gioco e $q$ è il numero di possibili mosse, è facile convincersi che il numero di mosse aumenta con l'aumentare dell'albero e inizia a diminuire una volta raggiunto un punto di "saturazione", quindi, si è provato che $\log q =$ O$(h\log h)$.\\
La complessità ottenuta è quindi:
\begin{equation*}
depth \cdot h(MK+NK)+depth(h\log h)=\\
\end{equation*}
\begin{equation*}
=depth \cdot h(MK+NK+\log h).\\
\end{equation*}
Il costo computazionale della funzione \texttt{createTree} è O$(depth \cdot h(MK+NK+\log h))$, dove $h$ è l'altezza dell'albero e \textit{depth} è il livello di profondità fino al quale generare.

\newpage
Di seguito, le robe brutte:
\newpage

\subsection*{Valutazione mosse "interessanti"}
\textbf{DA RIFARE TUTTA DA CAPO :)}\\
Per ricercare mosse successive a partire da un nodo il cui stato di gioco non sia terminale, viene richiamata la funzione \texttt{getInterestingPositions} che restituisce una coda con priorità di posizioni organizzate in ordine crescente di punteggio.\\
La funzione \texttt{getInterestingPositions(Node node, BoardStatus board)} prende in input un nodo ed effettua la scansione di tutte le celle adiacenti alle posizioni già marcate e di queste ne calcola il punteggio euristico relativo sia al giocatore che all'avversario e li inserisce nella coda.\\
Quindi, all'interno della funzione \texttt{createTree} vengono estratte dalla coda tutte le mosse con un punteggio minore o uguale a \texttt{SCORE\_THRESHOLD} ed eventualmente altre mosse fino al raggiungimento del valore minimo \texttt{MIN\_EVAL} o fino a coda vuota.

\subsection*{Interfaccia \texttt{MNKPlayer}}
\textbf{DA AGGIUSTARE (POSIZIONE)}\\
% ---------------------------------- CAMBIARE NOME AD OURPLAYER ----------------------------------
L'interfaccia \texttt{MNKPlayer} viene implementata dalla classe \texttt{OurPlayer} che contiene, tra gli attributi, un oggetto \texttt{GameTree}.\\
La funzione \texttt{selectCell}, quindi, restituisce la mossa da eseguire basandosi sullo stato dell'oggetto \texttt{GameTree}:
\begin{algorithm*}
\SetAlgoLined
\texttt{MNKCell} mossaScelta $\gets$ \texttt{null}\\
\vspace{0.2cm}
\eIf{gameTree.isEmpty()}{
	\eIf{gioco per primo}{
		mossaScelta $\gets$ \textit{centro della griglia}\\
		gameTree.generate(mossaScelta)
	}{
		gameTree.generate(\textit{mossa dell'avversario})\\
		mossaScelta $\gets$ gameTree.nextMove()
	}
}{
	gameTree.setOpponentMove(\textit{mossa dell'avversario})\\
	mossaScelta $\gets$ gameTree.nextMove()
}
\end{algorithm*}

\subsection*{Albero di gioco (FORSE SCOMPARE)}
Per la valutazione e la scelta della mossa da eseguire viene implementato un albero di gioco gestito nella classe \texttt{GameTree}.\\
Ciascun nodo dell'albero contiene:
\begin{itemize}
\setlength\itemsep{0.05cm}
	\item La descrizione del nodo rappresentato
	\item Il riferimento al nodo padre e una lista concatenata contenente i figli
	\item Un punteggio euristico
\end{itemize}

\subsection*{Generazione parziale dell'albero}
Il numero dei nodi generati dell'albero di gioco cresce in modo esponenziale all'aumentare dell'altezza;
per tale ragione è impossibile generare l'intero albero per configurazioni di gioco con un elevato numero di celle.\\
La generazione dell'albero deve essere quindi limitata sia in altezza che nel numero di nodi da elaborare.\\
All'interno della classe \texttt{GameTree} sono quindi presenti le costanti \texttt{MAX\_DEPTH} e \texttt{MIN\_EVAL} rispettivamente l'altezza massima generabile e il numero indicativo di figli di ciascun nodo (variabile in base al numero di scenari favorevoli o sfavorevoli).\\
Al termine di ogni fase di generazione dell'albero, la struttura viene elaborata dall'algoritmo \texttt{AlphaBeta Pruning} per propagare i punteggi delle foglie alla radice ed eventualmente tagliare determinati sottoalberi inconvenienti.\\
\textbf{CONTINUARE}\\
Per mantenere costante in altezza l'albero, in seguito alla selezione di una mossa, viene richiamata la funzione \texttt{extendLeaves(Node root)} che estende le foglie dell'albero radicato nel nodo in input.

\section*{Conclusione}
Il progetto è stato caruccio ma non lo rifarei.

\end{document}

